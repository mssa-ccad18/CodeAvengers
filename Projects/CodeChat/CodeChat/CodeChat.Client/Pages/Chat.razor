@page "/chat/{RoomName}"
@rendermode InteractiveWebAssembly
@using Microsoft.AspNetCore.SignalR.Client
@using Client.Components.Models
@using Client.Services.Encryption
@using Client.Services
@implements IAsyncDisposable
@inject NavigationManager Navigation
@inject IJSRuntime _jsRuntime
@inject ChatEncryptionService _encryptionService
@inject UserSessionService Session

<PageTitle>@RoomName</PageTitle>

<link href="css/chat.css" rel="stylesheet" />

<div class="chat-container">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="room-header">
            <span class="room-name">Room Name</span>
        </div>
        <!-- User list -->
        <div class="user-list">
            <div class="user-item user-owner">
                <span>Owner</span>
            </div>
            <div class="user-item">
                <span>User 1</span>
            </div>
            <div class="user-item">
                <span>User 2</span>
            </div>
        </div>
    </div>

    <!-- Main Chat Area -->
    <div class="chat-area">
        <div class="chat-header">
            <span class="room-name">Room Name</span>
        </div>

        <div class="chat-messages" id="messageContainer">
            @foreach (var message in Messages)
            {
                <!-- Decrypt message -->
                var content = DecryptMessage(message);
                <div>@message.Sender: @content</div>
            }
        </div>
    </div>
</div>

<!-- GPT-style Bottom Chat Bar -->
<div class="chat-input-bar">
    <textarea class="chat-input" placeholder="Type a message here..." @bind="messageInput"></textarea>
    <button class="chat-send-button" @onclick="SendMessage">
        Send
    </button>
</div>

@code {
    [Parameter]
    public string RoomName { get; set; } = string.Empty;


    private HubConnection? hubConnection;
    private List<ChatMessage> Messages = new();
    private byte[]? publicKey;
    private string? messageInput;
    private string? username;
    private string? RoomID;
    private string? status = string.Empty;


    protected override async Task OnInitializedAsync()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/chathub"))
            .Build();

        await hubConnection.StartAsync();

        RoomID = await hubConnection.InvokeAsync<string>("ValidateRoom", RoomName);
        if (RoomID == null) {
            // Handle room not found
            Navigation.NavigateTo("/error");
            return;
        }

        // get the chat history
        Messages = await hubConnection.InvokeAsync<List<ChatMessage>>("RequestChatHistory", RoomName);

        // listen for the incoming encrypted room key 
        await RecieveRoomKey();

        // listen for incoming messages
        await ListenForMessages();

        if (Session.Username != null) {
            username = Session.Username; // This retrieves the username
        } else {
            Navigation.NavigateTo("/error");
            return;
        }
        // get the public key for the user
        publicKey = await _jsRuntime.InvokeAsync<byte[]>("getPublicKey", username);
    }

    private async Task ListenForMessages() {
        if (hubConnection is not null) {

        }
    }

    private async Task<string> DecryptMessage(ChatMessage message) {
        // decrypt the message
        var decryptedMessage = await _jsRuntime.InvokeAsync<string>("decryptMessage", message.Content);
        return decryptedMessage;
    }
    
    /* @Task ListenForMessages
     *
     * ListenForMessages is called when a message is received from the server.
     * It adds the message to the Messages list and updates the UI.
     * @param: message The message to be added to the chat history.
     */
    public async Task ListenForMessages(ChatMessage message) {
        hubConnection.On<ChatMessage>("RecieveMessage", async (message) => {
            status = "Message received";
            Messages.Add(message);
            StateHasChanged();
            await hubConnection.SendAsync("AddEncryptedMessageToChatHistory", RoomID, message);
        });
    }
       
    /* @Task RecieveRoomKey
     *
     * RecieveRoomKey is called when an encrypted room key is received from the server.
     * It decrypts the room key and stores it in the browser's local storage.
     * @param: roomID The ID of the room for which the key is being sent.
     * @param: encryptedKey The encrypted room key.
     */
    public async Task RecieveRoomKey() {
        hubConnection.On<string, byte[], byte[]>("RecieveEncryptedRoomKey", async (roomID, encryptedKey, Iv) => {
            status = "Encrypted room key received";
            // decrypt the room key
            var decryptedKey = _encryptionService.DecryptMessage(encryptedKey, Iv, publicKey);
            // store the decrypted key in local storage
            await _jsRuntime.InvokeVoidAsync("storeDecryptedKey", roomID, decryptedKey);

        }); 
    }

    public async Task<byte[]> GetDecryptedRoomKey(string roomID) {
        // get the decrypted key
        var decryptedKey = await _jsRuntime.InvokeAsync<byte[]>("getDecryptedKey", roomID);
        return decryptedKey;
    }

    private async Task SendMessage()
    {
        if (hubConnection is not null && !string.IsNullOrEmpty(messageInput) && !string.IsNullOrEmpty(username))
        {
            // encrypt the message
            var encryptedMessage = await _jsRuntime.InvokeAsync<byte[]>("encryptMessage", RoomID, messageInput);
            var message = new ChatMessage {
                    Sender = username,
                    Content = encryptedMessage,
                    Timestamp = DateTime.Now
                };
            Messages.Add(message);
            await hubConnection.SendAsync("DistributeMessage", RoomID,  message);
            

            // update the ChatHistory
            messageInput = string.Empty;
        }
    }

    public bool IsConnected =>
        hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }
}