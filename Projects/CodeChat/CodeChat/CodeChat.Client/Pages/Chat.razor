@page "/chat/{RoomName}"
@rendermode InteractiveWebAssembly
@using Microsoft.AspNetCore.SignalR.Client
@using CodeChat.Client.Components.Models
@using CodeChat.Client.Services.Encryption
@using CodeChat.Client.Services
@inject NavigationManager Navigation
@inject IJSRuntime _jsRuntime
@inject ChatEncryptionService _encryptionService
@inject UserSessionService Session

<PageTitle>@RoomName</PageTitle>

<link href="css/chat.css" rel="stylesheet" />
<script src="crypto.js"></script>

<div class="chat-container">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="room-header">
            <span class="room-name">@RoomName</span>
        </div>
        <!-- User list -->
        <div class="user-list">
            <div class="user-item user-owner">
                <span>Owner</span>
            </div>
            <div class="user-item">
                <span>User 1</span>
            </div>
            <div class="user-item">
                <span>User 2</span>
            </div>
        </div>
    </div>

    <!-- Main Chat Area -->
    <div class="chat-area">
        <div class="chat-header">
            <span class="room-name">Room Name</span>
        </div>

        <div class="chat-messages" id="messageContainer">
            <div class="status-message">
                @status
            </div>
            @foreach (var message in Messages)
            {
                <!-- Decrypt message -->
                var content = DecryptMessage(message);
                <div>@message.Sender: @content.Result</div>
            }
        </div>
    </div>
</div>

<!-- GPT-style Bottom Chat Bar -->
<div class="chat-input-bar">
    <textarea class="chat-input" placeholder="Type a message here..." @bind="messageInput"></textarea>
    <button class="chat-send-button" @onclick="SendMessage">
        Send
    </button>
</div>

@code {
    [Parameter]
    public string RoomName { get; set; } = string.Empty;


    private HubConnection? hubConnection;
    private List<ChatMessage> Messages = new();
    private byte[]? publicKey;
    private string? messageInput;
    private string? username;
    private string? RoomID;
    private byte[]? roomKey;
    private string? status = string.Empty;


    protected override async Task OnInitializedAsync()
    {
        try 
        {
            hubConnection = new HubConnectionBuilder()
                .WithUrl(Navigation.ToAbsoluteUri("/chathub"))
                .WithAutomaticReconnect()
                .Build();

            hubConnection.Closed += async (error) =>
            {
                await Task.Delay(new Random().Next(0, 5) * 1000);
                await hubConnection.StartAsync();
            };

            await hubConnection.StartAsync();

            RoomID = await hubConnection.InvokeAsync<string>("ValidateRoom", RoomName);
            if (RoomID == null) {
                Navigation.NavigateTo("/error");
                return;
            }

            if (Session.Username != null) {
                username = Session.Username;
            } else {
                Navigation.NavigateTo("/error");
                return;
            }

            publicKey = await hubConnection.InvokeAsync<byte[]>("GetUserPublicKey", username);

            RecieveRoomKey();
            Messages = await hubConnection.InvokeAsync<List<ChatMessage>>("RequestChatHistory", RoomName);

            ListenForMessages();
        }
        catch (Exception ex)
        {
            status = $"Error: {ex.Message}";
        }
    }

    private void ListenForMessages() {
        if (hubConnection is not null) {
            hubConnection.On<ChatMessage>("ReceiveMessage", async (message) => {
                status = "Message received";
                Messages.Add(message);
                StateHasChanged();
                if (hubConnection is not null) {
                    await hubConnection.SendAsync("AddEncryptedMessageToChatHistory", RoomID, message);
                } else
                {
                    status = "Error sending message to chat history";
                    StateHasChanged();
                }
            });
        }
    }

    private ValueTask<string> DecryptMessage(ChatMessage message) {
        // decrypt the message
        var decryptedMessage = _jsRuntime.InvokeAsync<string>("decryptMessage", message.Content, RoomID);
        return decryptedMessage;
    }

    /* @Task RecieveRoomKey
     *
     * RecieveRoomKey is called when an encrypted room key is received from the server.
     * It decrypts the room key and stores it in the browser's local storage.
     * @param: roomID The ID of the room for which the key is being sent.
     * @param: encryptedKey The encrypted room key.
     */
    public void RecieveRoomKey() {
        if (hubConnection is not null && publicKey is not null) {
            hubConnection.On<byte[]>("RecieveEncryptedRoomKey", async (encryptedKey) => {
                status = "Encrypted room key received";
                // decrypt the room key
                
                var decryptedKey = await _jsRuntime.InvokeAsync<byte[]>("decryptRoomKey", encryptedKey);
                // store the decrypted key in local storage
                roomKey = decryptedKey;
                // await _jsRuntime.InvokeVoidAsync("storeDecryptedKey", RoomID, decryptedKey);
            }); 
        }
    }

    public async Task<byte[]> GetDecryptedRoomKey(string roomID) {
        // get the decrypted key
        var decryptedKey = await _jsRuntime.InvokeAsync<byte[]>("getDecryptedKey", roomID);
        return decryptedKey;
    }

    private async Task SendMessage()
    {
        if (hubConnection is not null && !string.IsNullOrEmpty(messageInput) && !string.IsNullOrEmpty(username))
        {
            // encrypt the message
            var encryptedMessage = await _jsRuntime.InvokeAsync<byte[]>("encryptMessage", RoomID, messageInput, roomKey);
            var message = new ChatMessage {
                    Sender = username,
                    Content = encryptedMessage,
                    Timestamp = DateTime.Now
                };
            Messages.Add(message);
            await hubConnection.SendAsync("DistributeMessage", RoomID,  message);
            

            // update the ChatHistory
            messageInput = string.Empty;
        }
    }

    public bool IsConnected =>
        hubConnection?.State == HubConnectionState.Connected;
}